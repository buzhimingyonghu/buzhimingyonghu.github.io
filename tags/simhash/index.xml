<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Simhash on Victor的世界</title>
    <link>//localhost:1313/tags/simhash/</link>
    <description>Recent content in Simhash on Victor的世界</description>
    <generator>Hugo</generator>
    <language>zh</language>
    <lastBuildDate>Thu, 20 Jun 2024 19:42:02 +0800</lastBuildDate>
    <atom:link href="//localhost:1313/tags/simhash/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>基于Simhash实现PSM概率性匹配系统</title>
      <link>//localhost:1313/posts/zh/opensource/%E5%9F%BA%E4%BA%8Esimhash%E5%AE%9E%E7%8E%B0psm%E6%A6%82%E7%8E%87%E6%80%A7%E5%8C%B9%E9%85%8D%E7%B3%BB%E7%BB%9F/</link>
      <pubDate>Thu, 20 Jun 2024 19:42:02 +0800</pubDate>
      <guid>//localhost:1313/posts/zh/opensource/%E5%9F%BA%E4%BA%8Esimhash%E5%AE%9E%E7%8E%B0psm%E6%A6%82%E7%8E%87%E6%80%A7%E5%8C%B9%E9%85%8D%E7%B3%BB%E7%BB%9F/</guid>
      <description>&lt;p&gt;&lt;strong&gt;基于Simhash实现PSM概率性匹配系统&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;p&gt;PSM系统，即概率性&lt;strong&gt;Simhash匹配系统&lt;/strong&gt;（Probabilistic Simhash Matching System），是一种用于高效检测近似重复图像或文档的算法系统。它利用&lt;strong&gt;Simhash技术&lt;/strong&gt;，通过概率性匹配方法来快速识别和定位相似度较高的对象。&#xA;&lt;img src=&#34;./images/1280X1280.PNG&#34; alt=&#34;simhash&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;Simhash和汉明距离&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;p&gt;Simhash由Moses Charikar开发，并在他的论文“Similarity Estimation Techniques from Rounding Algorithms”中描述。Simhash的主要目的是将相似的项目哈希到相似的哈希值。相似性可以通过哈希值之间的位汉明距离来判断。&lt;/p&gt;&#xA;&lt;p&gt;以下是将一个n维实数向量映射到一个f位Simhash的算法。&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;算法1：计算实数向量的Simhash&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;输入：&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;p&gt;v[1..n]：输入实数向量&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;输出：&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;p&gt;s：f位Simhash&lt;/p&gt;&#xA;&lt;p&gt;初始化一个实数向量t[1..f]为0&lt;/p&gt;&#xA;&lt;p&gt;生成n个f位随机整数r[1..n]&lt;/p&gt;&#xA;&lt;p&gt;对于i从1到n，执行以下步骤：&lt;/p&gt;&#xA;&lt;p&gt;对于j从1到f，执行以下步骤：&lt;/p&gt;&#xA;&lt;p&gt;如果r[i]的第j位是1，则t[j] ← t[j] + v[i]&lt;/p&gt;&#xA;&lt;p&gt;否则，t[j] ← t[j] − v[i]&lt;/p&gt;&#xA;&lt;p&gt;对于i从1到f，执行以下步骤：&lt;/p&gt;&#xA;&lt;p&gt;如果t[i] ≥ 0，则将s的第i位设为1&lt;/p&gt;&#xA;&lt;p&gt;否则，将s的第i位设为0&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;近似重复检测&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;p&gt;一般来说，如果两个Simhash的汉明距离不超过h（h是一个经验阈值），我们可以认为它们是近似重复的。要在一个包含m个Simhash的数据库中找到一个Simhash的所有近似重复，最简单的方法是进行一次完整的线性扫描，这需要计算m次汉明距离。&lt;/p&gt;&#xA;&lt;p&gt;随着m的增长，完整线性扫描的时间成本将变得不可接受。事实上，大多数汉明距离计算是没有必要的，因为对于每个查询的Simhash，只有少数近似重复可以找到。已经提出了几种解决方案来减少比较的时间，例如Manku等人（2007年）。&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;位翻转组合&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;p&gt;我们考虑Sood和Luguinov提出的一种新方法，即概率性Simhash匹配（PSM）系统，该系统在不需要维护数据的多个副本以进行近似重复搜索的情况下，仍然保持了良好的召回率。对于给定的查询指纹，我们基于找到近似重复匹配的概率探索不同的现有指纹，并限制我们的尝试次数以实现良好的查询速度。&lt;/p&gt;&#xA;&lt;p&gt;首先，我们可以对Si69521mhash数据库进行排序并建立一个索引。为了更好地理解这里的“索引”，假设所有的Simhash都是f位整数并按列表排序，我们根据每个Simhash的前p位将它们分成子列表，然后所有子列表中第一个元素的位置组成一个索引。例如，索引的第32767个元素表示Simhash列表中前p位等于0x7fff的最小元素的位置。由于汉明距离阈值h通常是2或3，我们可以轻松构建位翻转组合，这意味着查询Simhash的所有可能的前16位的近似重复。对于h=3和p=16的索引，我们需要扫描所有65536（2^16）个子列表进行完整线性扫描，但仅需要扫描C(p,0) + C(p,1) + C(p,2) + C(p,3) = 697个子列表，受益于位翻转组合。&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;计算Simhash&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;Simhash 原理概述&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;p&gt;Simhash 的基本思想是通过特征向量的加权累加生成一个低维哈希值，进而用于判断相似性。对于文本来说，特征可以是单词或词组，对于实数向量来说，特征就是向量的每一个分量。&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;将实数向量映射到 Simhash 的过程&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;p&gt;对于文本，我们通常将每个单词哈希为一个固定长度的位串，并根据单词的权重对这些位串进行加权累加。而对于实数向量，我们可以使用类似的过程，将每个向量分量视为一个特征，进行加权累加。具体步骤如下：&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;输入：&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;p&gt;v[1..n]v[1..n]v[1..n]：输入的实数向量&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;输出：&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;p&gt;sss：f 位 Simhash&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;步骤：&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;初始化向量&lt;/strong&gt;：&lt;/p&gt;&#xA;&lt;p&gt;初始化一个长度为 f 的实数向量 t[1..f]t[1..f]t[1..f]，所有值设为 0。&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
