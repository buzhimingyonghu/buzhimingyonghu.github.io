<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Victor的世界</title>
    <link>//localhost:1313/</link>
    <description>Recent content on Victor的世界</description>
    <generator>Hugo</generator>
    <language>zh</language>
    <lastBuildDate>Tue, 18 Feb 2025 19:42:02 +0800</lastBuildDate>
    <atom:link href="//localhost:1313/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>PacificA解读</title>
      <link>//localhost:1313/posts/zh/distributed/pacifica-test-cases/</link>
      <pubDate>Tue, 18 Feb 2025 19:42:02 +0800</pubDate>
      <guid>//localhost:1313/posts/zh/distributed/pacifica-test-cases/</guid>
      <description>&lt;h2 id=&#34;摘要&#34;&gt;摘要&lt;/h2&gt;&#xA;&lt;p&gt;大规模分布式存储因数据量增长而广受关注，复制机制是实现高可用性和高吞吐的关键。尽管共识研究为复制协议奠定基础，但架构设计和工程实现仍具挑战。本文分享了PacificA协议基于日志的存储系统设计复制机制的经验，提出一种简单、实用、强一致的通用复制框架，展示其支持多种设计选择的灵活性。&lt;/p&gt;&#xA;&lt;hr&gt;&#xA;&lt;h1 id=&#34;1-pacifica-流程&#34;&gt;1. PacificA 流程&lt;/h1&gt;&#xA;&lt;p&gt;系统通过主从模式实现数据复制，每份数据由一个副本组负责，组内指定主服务器，其余为备份，配置变化由版本号跟踪。本文关注强一致性复制协议，确保分布式系统行为与单机一致（线性一致性）。&lt;/p&gt;&#xA;&lt;h2 id=&#34;11-主从复制&#34;&gt;1.1 主从复制&lt;/h2&gt;&#xA;&lt;p&gt;我们将客户端请求分为两类：&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;读数据的查询请求&lt;/li&gt;&#xA;&lt;li&gt;写数据的更新请求。&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;如果复制组中的所有服务器以相同顺序处理相同的请求集（假设更新是确定性的），则可以实现强一致性。因此，主服务器为更新分配连续且单调递增的序列号，并指示所有备服务器按此顺序连续处理请求。&lt;/p&gt;&#xA;&lt;h3 id=&#34;正常情况下的处理流程&#34;&gt;正常情况下的处理流程：&lt;/h3&gt;&#xA;&lt;h4 id=&#34;读请求的处理&#34;&gt;读请求的处理：&lt;/h4&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;当主服务器接收到读请求时，它直接使用当前提交列表中（未实现）记录的状态来处理请求。查询请求不影响数据的一致性，因此主服务器可以立刻返回结果。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h4 id=&#34;写请求的处理&#34;&gt;写请求的处理：&lt;/h4&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;主服务器会为写请求分配一个递增的全局序列号，确保所有请求按照固定的顺序处理。&lt;/li&gt;&#xA;&lt;li&gt;主服务器会将包含配置版本（未实现）和序列号的请求和CommittedID，通过一个 &lt;code&gt;prepare&lt;/code&gt; 消息发送给所有从服务器。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h4 id=&#34;从服务器的处理&#34;&gt;从服务器的处理：&lt;/h4&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;每个备服务器在收到 &lt;code&gt;prepare&lt;/code&gt; 消息后，会按照序列号顺序将请求添加到自己的准备列表中，将请求标记为“已准备”。&lt;/li&gt;&#xA;&lt;li&gt;随后，备服务器向主服务器发送一个 &lt;code&gt;prepared&lt;/code&gt; 消息作为确认。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h4 id=&#34;提交到状态机&#34;&gt;提交到状态机：&lt;/h4&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;当主服务器收到所有从服务器的确认后，才会将该请求标记为已提交。此时，主服务器更新它的提交点，使其指向已提交的最高序列号位置。&lt;/li&gt;&#xA;&lt;li&gt;主服务器会向客户端返回确认消息，表示请求已成功完成。&lt;/li&gt;&#xA;&lt;li&gt;在每次发送 &lt;code&gt;prepare&lt;/code&gt; 消息时，主服务器还会附带当前提交点的序列号，告知备服务器哪些请求已经提交。这样，备服务器可以将自己的提交点前移，与主服务器保持一致。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;一致性保证&#34;&gt;一致性保证：&lt;/h3&gt;&#xA;&lt;p&gt;主服务器仅在所有从服务器将请求添加到准备列表后，才会将其加入提交列表，确保提交列表与备服务器的准备列表一致且包含于其中。同时，从服务器仅在主服务器标记请求为提交后，才会将其视为已提交，确保备服务器的提交列表始终包含于主服务器的提交范围内。&lt;/p&gt;&#xA;&lt;h3 id=&#34;提交-invariant&#34;&gt;提交 Invariant：&lt;/h3&gt;&#xA;&lt;p&gt;形成了“提交 Invariant”，即对于主服务器 &lt;code&gt;p&lt;/code&gt; 和任何备服务器 &lt;code&gt;q&lt;/code&gt;，始终有：&lt;/p&gt;&#xA;&lt;p&gt;committedq ⊆ committedp ⊆ preparedq&lt;/p&gt;&#xA;&lt;p&gt;这保证了主备之间的数据一致性和同步。&lt;/p&gt;&#xA;&lt;hr&gt;&#xA;&lt;h2 id=&#34;12-配置管理&#34;&gt;1.2 配置管理&lt;/h2&gt;&#xA;&lt;h3 id=&#34;设计一个全局配置管理器&#34;&gt;设计一个全局配置管理器：&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;负责管理和维护系统中所有副本组的配置。&lt;/li&gt;&#xA;&lt;li&gt;对于每个副本组，配置管理器会保存当前的配置和配置版本。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;全局配置管理器的功能&#34;&gt;全局配置管理器的功能：&lt;/h3&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;strong&gt;重新配置&lt;/strong&gt;：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;检测副本是否出现故障，决定是否移除副本，或者重启副本配置。&lt;/li&gt;&#xA;&lt;li&gt;添加新的副本。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;strong&gt;增添从节点&lt;/strong&gt;：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;根据设定的规则决定是否添加新配置。&lt;/li&gt;&#xA;&lt;li&gt;配置规则：是否版本匹配，检测副本的 &lt;code&gt;committedID&lt;/code&gt; 是否匹配（是否存在，是否小于主的 &lt;code&gt;committedID&lt;/code&gt;）。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;strong&gt;主崩溃后，重新配置&lt;/strong&gt;：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;如果发生网络分区，导致主服务器与副本之间断开连接，可能会出现冲突的重新配置请求。例如，主服务器可能希望移除一些副本，而某些副本则希望移除主服务器。&lt;/li&gt;&#xA;&lt;li&gt;依旧先检测是否匹配规则 &lt;code&gt;L&lt;/code&gt;，匹配成功后配置管理器接受的请求会“胜出”。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;strong&gt;故障检测和主服务器不变性&lt;/strong&gt;：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;主服务器不变性要求，在任何时刻，服务器 &lt;code&gt;p&lt;/code&gt; 只有在配置管理器认为它是当前配置中的主服务器时，才会将自己视为主服务器。这样可以确保在系统中，副本组中最多只有一台服务器会认为自己是主服务器。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h3 id=&#34;总结&#34;&gt;总结：&lt;/h3&gt;&#xA;&lt;p&gt;配置管理器负责协调和维护系统的配置，确保副本组的配置一致性、版本控制和故障恢复。主服务器不变性确保在系统中始终只有一个主服务器，而不会发生多个服务器同时作为主服务器的情况。&lt;/p&gt;</description>
    </item>
    <item>
      <title>PacificA 一致性测试用例说明</title>
      <link>//localhost:1313/posts/zh/pika/pacifica-test-cases/</link>
      <pubDate>Mon, 10 Feb 2025 19:42:02 +0800</pubDate>
      <guid>//localhost:1313/posts/zh/pika/pacifica-test-cases/</guid>
      <description>&lt;h2 id=&#34;测试用例1基础一致性测试&#34;&gt;测试用例1：基础一致性测试&lt;/h2&gt;&#xA;&lt;p&gt;&lt;strong&gt;目的&lt;/strong&gt;：验证主从复制的基本功能和数据一致性&#xA;&lt;strong&gt;步骤&lt;/strong&gt;：&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;向主节点写入数据&lt;/li&gt;&#xA;&lt;li&gt;验证两个从节点的数据同步情况&lt;/li&gt;&#xA;&lt;li&gt;检查所有节点的复制状态&#xA;&lt;strong&gt;预期结果&lt;/strong&gt;：所有节点数据完全一致，复制状态正常&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h2 id=&#34;测试用例2并发写入一致性测试&#34;&gt;测试用例2：并发写入一致性测试&lt;/h2&gt;&#xA;&lt;p&gt;&lt;strong&gt;目的&lt;/strong&gt;：确保并发写入时的数据一致性&#xA;&lt;strong&gt;步骤&lt;/strong&gt;：&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;向主节点并发写入10条数据&lt;/li&gt;&#xA;&lt;li&gt;等待数据同步完成&lt;/li&gt;&#xA;&lt;li&gt;验证两个从节点的所有数据&#xA;&lt;strong&gt;预期结果&lt;/strong&gt;：所有并发写入的数据都正确同步到从节点&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h2 id=&#34;测试用例3网络分区恢复测试&#34;&gt;测试用例3：网络分区恢复测试&lt;/h2&gt;&#xA;&lt;p&gt;&lt;strong&gt;目的&lt;/strong&gt;：测试网络分区后的一致性恢复&#xA;&lt;strong&gt;步骤&lt;/strong&gt;：&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;写入初始数据&lt;/li&gt;&#xA;&lt;li&gt;断开从节点1连接（模拟网络分区）&lt;/li&gt;&#xA;&lt;li&gt;向主节点写入新数据&lt;/li&gt;&#xA;&lt;li&gt;恢复从节点1连接&lt;/li&gt;&#xA;&lt;li&gt;验证数据一致性&#xA;&lt;strong&gt;预期结果&lt;/strong&gt;：网络恢复后，断开的从节点应同步所有错过的数据&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h2 id=&#34;测试用例4动态节点添加测试&#34;&gt;测试用例4：动态节点添加测试&lt;/h2&gt;&#xA;&lt;p&gt;&lt;strong&gt;目的&lt;/strong&gt;：验证新增节点时的数据一致性&#xA;&lt;strong&gt;步骤&lt;/strong&gt;：&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;初始只启动主节点和一个从节点&lt;/li&gt;&#xA;&lt;li&gt;写入一批初始数据&lt;/li&gt;&#xA;&lt;li&gt;添加第二个从节点&lt;/li&gt;&#xA;&lt;li&gt;写入新的数据&lt;/li&gt;&#xA;&lt;li&gt;验证新旧数据的一致性&#xA;&lt;strong&gt;预期结果&lt;/strong&gt;：新加入的从节点应正确接收所有历史数据和新数据&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h2 id=&#34;测试用例5节点故障恢复测试&#34;&gt;测试用例5：节点故障恢复测试&lt;/h2&gt;&#xA;&lt;p&gt;&lt;strong&gt;目的&lt;/strong&gt;：测试节点故障和恢复时的系统行为&#xA;&lt;strong&gt;步骤&lt;/strong&gt;：&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;向所有节点写入初始数据&lt;/li&gt;&#xA;&lt;li&gt;模拟从节点1故障&lt;/li&gt;&#xA;&lt;li&gt;故障期间写入数据&lt;/li&gt;&#xA;&lt;li&gt;恢复从节点1&lt;/li&gt;&#xA;&lt;li&gt;写入新的数据&lt;/li&gt;&#xA;&lt;li&gt;验证所有数据集&#xA;&lt;strong&gt;预期结果&lt;/strong&gt;：&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;节点故障期间系统继续正常运行&lt;/li&gt;&#xA;&lt;li&gt;故障节点恢复后能同步所有错过的数据&lt;/li&gt;&#xA;&lt;li&gt;所有节点最终达到数据一致&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;测试环境&#34;&gt;测试环境&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;1个主节点（端口：9301）&lt;/li&gt;&#xA;&lt;li&gt;2个从节点（端口：9302，9303）&lt;/li&gt;&#xA;&lt;li&gt;启用强一致性模式&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;注意事项&#34;&gt;注意事项&lt;/h2&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;每个测试用例都包含足够的等待时间，确保数据同步完成&lt;/li&gt;&#xA;&lt;li&gt;所有测试都在强一致性模式下进行&lt;/li&gt;&#xA;&lt;li&gt;测试过程中会验证数据的完整性和一致性&lt;/li&gt;&#xA;&lt;/ol&gt;</description>
    </item>
    <item>
      <title>基于PacificA协议Pika主从一致性</title>
      <link>//localhost:1313/posts/zh/pika/pacifica-consistency/</link>
      <pubDate>Fri, 10 Jan 2025 19:42:02 +0800</pubDate>
      <guid>//localhost:1313/posts/zh/pika/pacifica-consistency/</guid>
      <description>&lt;h1 id=&#34;pacifica-协议概述&#34;&gt;PacificA 协议概述&lt;/h1&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://www.microsoft.com/en-us/research/wp-content/uploads/2008/02/tr-2008-25.pdf&#34;&gt;PacificA &lt;/a&gt;协议简单来说分为两部分：&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;- 数据复制&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;ol start=&#34;2&#34;&gt;&#xA;&lt;li&gt;配置管理&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;&lt;em&gt;由于在 Pika 中，配置管理主要由 &lt;code&gt;pika_sentinel&lt;/code&gt; 负责，本文主要关注通过主从模式的数据复制及其与 &lt;code&gt;pika_sentinel&lt;/code&gt; 配合的协调过程。&lt;/em&gt;&lt;/p&gt;&#xA;&lt;h2 id=&#34;在-pika-中的应用&#34;&gt;在 Pika 中的应用&lt;/h2&gt;&#xA;&lt;p&gt;主要分为三个部分：&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;PacificA 中主从模式的数据一致流程处理&lt;/li&gt;&#xA;&lt;li&gt;分布式日志型存储系统的设计&lt;/li&gt;&#xA;&lt;li&gt;故障恢复后的协调状态&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;hr&gt;&#xA;&lt;h2 id=&#34;启动-pacifica&#34;&gt;启动 PacificA&lt;/h2&gt;&#xA;&lt;p&gt;在 Pika 中，建立普通主从连接的命令为：&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;slaveof &amp;lt;ip&amp;gt; &amp;lt;port&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;如果需要启动 PacificA 协议，需要增加 strong 参数：&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;slaveof &amp;lt;ip&amp;gt; &amp;lt;port&amp;gt; strong&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;当从节点执行上述命令时，会触发 slaveofcmd，读取相关参数，并由 pika_server 保存这些信息，随后异步交由 PikaAuxiliaryThread 线程（以下简称 PAT）处理。&#xA;PAT 是 PacificA 协议中的核心辅助线程，负责：&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;- 状态机状态切换&#xA;- 主从之间的心跳发送及超时检查&#xA;- 主从之间的同步任务&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;pacifica-主从模式的数据一致流程&#34;&gt;PacificA 主从模式的数据一致流程&lt;/h2&gt;&#xA;&lt;h3 id=&#34;主从建立连接的四个阶段&#34;&gt;主从建立连接的四个阶段&lt;/h3&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;MetaSync：主从元数据的同步和检查&lt;/li&gt;&#xA;&lt;li&gt;TrySync：判断数据完整性，选择全量同步或增量同步&lt;/li&gt;&#xA;&lt;li&gt;Candidate：从节点作为候选者，追加完整的准备列表&lt;/li&gt;&#xA;&lt;li&gt;BinlogSync：正式加入集群，开始进行数据复制&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://github.com/user-attachments/assets/11268449-19db-4d14-af3b-0aebd9e54a54&#34; alt=&#34;image&#34;&gt;&#xA;下面是基本的数据结构：&#xA;&lt;img src=&#34;https://github.com/user-attachments/assets/d81d704d-34ce-4c8e-aaff-d4f137a45035&#34; alt=&#34;image&#34;&gt;&lt;/p&gt;&#xA;&lt;h2 id=&#34;metasync-阶段&#34;&gt;MetaSync 阶段&lt;/h2&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://github.com/user-attachments/assets/19e287da-0630-4381-b09e-75527ea76a20&#34; alt=&#34;image&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;从节点的 PAT 线程通过发送 MetaReq 请求与主节点建立连接，其中包含 is_consistency 字段，表示强一致性请求。&#xA;主节点收到请求后，若 consistency 标记为 true，则会：&lt;/p&gt;</description>
    </item>
    <item>
      <title>HNSW向量索引在Bustub中的实现</title>
      <link>//localhost:1313/posts/zh/vectordb/hnsw%E5%90%91%E9%87%8F%E7%B4%A2%E5%BC%95%E5%9C%A8bustub%E4%B8%AD%E7%9A%84%E5%AE%9E%E7%8E%B0/</link>
      <pubDate>Mon, 02 Dec 2024 19:42:02 +0800</pubDate>
      <guid>//localhost:1313/posts/zh/vectordb/hnsw%E5%90%91%E9%87%8F%E7%B4%A2%E5%BC%95%E5%9C%A8bustub%E4%B8%AD%E7%9A%84%E5%AE%9E%E7%8E%B0/</guid>
      <description>&lt;p&gt;HNSW (Hierarchical Navigable Small World) 是一种高效的近似最近邻(ANN)搜索算法，特别适用于高维向量数据的相似度搜索，支持向量的插入和近邻搜索操作。&#xA;&lt;img src=&#34;./images/1280X1280%281%29.PNG&#34; alt=&#34;HNSW&#34;&gt;&#xA;&lt;img src=&#34;./images/1280X1280.PNG&#34; alt=&#34;HNSW&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;本文主要从以下两个方面介绍HNSW的实现：&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;核心数据结构和算法实现&lt;/li&gt;&#xA;&lt;li&gt;向量检索和插入流程示例&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h2 id=&#34;核心数据结构和算法实现&#34;&gt;核心数据结构和算法实现&lt;/h2&gt;&#xA;&lt;h3 id=&#34;1-核心数据结构&#34;&gt;1. 核心数据结构&lt;/h3&gt;&#xA;&lt;h4 id=&#34;11-nsw-navigable-small-world&#34;&gt;1.1 NSW (Navigable Small World)&lt;/h4&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;struct&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;NSW&lt;/span&gt; {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;vector&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;Vector&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;vertices_;         &lt;span style=&#34;color:#75715e&#34;&gt;// 所有向量数据&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;  std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;unordered_map&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;size_t, std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;vector&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;size_t&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&amp;gt;&lt;/span&gt; edges_;  &lt;span style=&#34;color:#75715e&#34;&gt;// 邻接表&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;  std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;vector&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;size_t&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; in_vertices_;       &lt;span style=&#34;color:#75715e&#34;&gt;// 该层包含的顶点&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;  VectorExpressionType dist_fn_;          &lt;span style=&#34;color:#75715e&#34;&gt;// 距离计算函数&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;  size_t m_max_;                         &lt;span style=&#34;color:#75715e&#34;&gt;// 最大边数限制&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;}&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h4 id=&#34;12-hnswindex&#34;&gt;1.2 HNSWIndex&lt;/h4&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;HNSWIndex&lt;/span&gt; {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;unique_ptr&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;vector&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;Vector&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&amp;gt;&lt;/span&gt; vertices_;  &lt;span style=&#34;color:#75715e&#34;&gt;// 向量数据&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;  std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;vector&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;RID&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; rids_;                         &lt;span style=&#34;color:#75715e&#34;&gt;// 记录ID&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;  std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;vector&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;NSW&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; layers_;                       &lt;span style=&#34;color:#75715e&#34;&gt;// 多层图结构&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;  &#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#75715e&#34;&gt;// 配置参数&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;  size_t m_;                &lt;span style=&#34;color:#75715e&#34;&gt;// 每个节点的邻居数&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;  size_t ef_construction_;  &lt;span style=&#34;color:#75715e&#34;&gt;// 构建时的候选集大小&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;  size_t ef_search_;       &lt;span style=&#34;color:#75715e&#34;&gt;// 搜索时的候选集大小&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#66d9ef&#34;&gt;double&lt;/span&gt; m_l_;             &lt;span style=&#34;color:#75715e&#34;&gt;// 层级计算参数&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;}&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;2-核心算法实现&#34;&gt;2. 核心算法实现&lt;/h3&gt;&#xA;&lt;h4 id=&#34;21-搜索算法&#34;&gt;2.1 搜索算法&lt;/h4&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;auto&lt;/span&gt; NSW&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;SearchLayer(&lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; vector&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;double&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;query, size_t limit, &lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; vector&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;size_t&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;entry_points)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;&#xA;&lt;li&gt;采用贪心搜索策略&lt;/li&gt;&#xA;&lt;li&gt;使用优先队列维护候选集和结果集&lt;/li&gt;&#xA;&lt;li&gt;通过距离比较进行剪枝优化&lt;/li&gt;&#xA;&lt;li&gt;搜索过程：&#xA;&lt;ol&gt;&#xA;&lt;li&gt;从入口点开始搜索&lt;/li&gt;&#xA;&lt;li&gt;遍历当前节点的邻居&lt;/li&gt;&#xA;&lt;li&gt;更新候选集和结果集&lt;/li&gt;&#xA;&lt;li&gt;当候选集最小距离大于结果集最大距离时终止&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h4 id=&#34;22-插入算法&#34;&gt;2.2 插入算法&lt;/h4&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; HNSWIndex&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;InsertVectorEntry(&lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; vector&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;double&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;key, RID rid)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;&#xA;&lt;li&gt;插入步骤：&#xA;&lt;ol&gt;&#xA;&lt;li&gt;生成随机层级&lt;/li&gt;&#xA;&lt;li&gt;从最高层开始搜索合适的插入位置&lt;/li&gt;&#xA;&lt;li&gt;在目标层及以下建立连接&lt;/li&gt;&#xA;&lt;li&gt;优化各层的邻居连接&lt;/li&gt;&#xA;&lt;li&gt;必要时创建新层&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;3-重要参数说明&#34;&gt;3. 重要参数说明&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;code&gt;m&lt;/code&gt;：每个节点的最大邻居数&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;ef_construction&lt;/code&gt;：构建索引时的候选集大小&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;ef_search&lt;/code&gt;：查询时的候选集大小&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;m_max_&lt;/code&gt;：非底层的最大边数&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;m_max_0_&lt;/code&gt;：底层的最大边数（= m * m）&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;向量检索和插入流程示例&#34;&gt;向量检索和插入流程示例&lt;/h2&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&lt;strong&gt;索引结构&lt;/strong&gt;:&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;层级3:   o---o  (稀疏连接)&#xA;层级2:   o---o---o  (中等密度连接)&#xA;层级1:   o---o---o---o  (较密连接)&#xA;层级0:   o---o---o---o---o---o  (最密连接，包含所有节点)&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;ol start=&#34;2&#34;&gt;&#xA;&lt;li&gt;&lt;strong&gt;插入流程&lt;/strong&gt; (&lt;code&gt;InsertVectorEntry&lt;/code&gt;):&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; HNSWIndex&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;InsertVectorEntry(&lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;vector&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;double&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;key, RID rid) {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#75715e&#34;&gt;// 1. 随机决定新节点的最高层级&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; target_level &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; GenerateRandomLevel();&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#75715e&#34;&gt;// 2. 将向量数据和RID添加到存储中&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#66d9ef&#34;&gt;auto&lt;/span&gt; vertex_id &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; AddVertex(key, rid);&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#75715e&#34;&gt;// 3. 自顶向下插入过程&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (&lt;span style=&#34;color:#f92672&#34;&gt;!&lt;/span&gt;layers_[&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;].in_vertices_.empty()) {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// 3.1 从最高层开始搜索&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;vector&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;size_t&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; entry_points &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; {&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;最高层的入口点&lt;/span&gt;};&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// 3.2 在高于目标层的层中只更新entry_points&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; (level &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; max_level; level &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; target_level; level&lt;span style=&#34;color:#f92672&#34;&gt;--&lt;/span&gt;) {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;找到当前层最近的节点&lt;/span&gt;;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;将这些节点作为下一层的入口点&lt;/span&gt;;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// 3.3 在目标层及以下的层中建立连接&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; (; level &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;; level&lt;span style=&#34;color:#f92672&#34;&gt;--&lt;/span&gt;) {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;找到当前层最近的&lt;/span&gt;ef_construction个节点;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;选择最近的&lt;/span&gt;m个作为邻居;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;建立双向连接&lt;/span&gt;;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;优化邻居的连接&lt;/span&gt;(&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;确保不超过最大连接数&lt;/span&gt;);&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  }&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#75715e&#34;&gt;// 4. 如果需要，创建新的层&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#66d9ef&#34;&gt;while&lt;/span&gt; (layers_.size() &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;=&lt;/span&gt; target_level) {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;创建新层并添加当前节点&lt;/span&gt;;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  }&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ol start=&#34;3&#34;&gt;&#xA;&lt;li&gt;&lt;strong&gt;搜索流程&lt;/strong&gt; (&lt;code&gt;ScanVectorKey&lt;/code&gt;):&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;auto&lt;/span&gt; HNSWIndex&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;ScanVectorKey(&lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;vector&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;double&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;query, size_t k) {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#75715e&#34;&gt;// 1. 从最高层开始&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;  entry_points &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; {&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;最高层的入口点&lt;/span&gt;};&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#75715e&#34;&gt;// 2. 逐层向下搜索&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; (level &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; max_level; level &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;; level&lt;span style=&#34;color:#f92672&#34;&gt;--&lt;/span&gt;) {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// 在当前层找到最近的节点&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    entry_points &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; layers_[level].SearchLayer(query, k, entry_points);&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  }&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#75715e&#34;&gt;// 3. 在底层进行最终搜索&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;  final_results &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; layers_[&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;].SearchLayer(query, k, entry_points);&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#75715e&#34;&gt;// 4. 转换结果为RID并返回&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;转换为&lt;/span&gt;RID列表;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ol start=&#34;4&#34;&gt;&#xA;&lt;li&gt;&lt;strong&gt;单层搜索流程&lt;/strong&gt; (&lt;code&gt;SearchLayer&lt;/code&gt;):&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;auto&lt;/span&gt; NSW&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;SearchLayer(&lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; vector&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;double&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;query, size_t k, &lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; vector&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;size_t&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;entry_points) {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#75715e&#34;&gt;// 1. 初始化搜索状态&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;  candidate_queue &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;空队列&lt;/span&gt;;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  result_set &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;空优先队列&lt;/span&gt;;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  visited &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;空集合&lt;/span&gt;;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#75715e&#34;&gt;// 2. 将入口点加入候选集&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; (entry_point : entry_points) {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;计算距离&lt;/span&gt;;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;加入候选队列和结果集&lt;/span&gt;;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  }&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#75715e&#34;&gt;// 3. 贪心搜索&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#66d9ef&#34;&gt;while&lt;/span&gt; (&lt;span style=&#34;color:#f92672&#34;&gt;!&lt;/span&gt;candidate_queue.empty()) {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    current &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; candidate_queue.front();&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// 3.1 获取当前节点的邻居&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    neighbors &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; edges_[current];&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// 3.2 处理每个未访问的邻居&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; (neighbor : neighbors) {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;已访问&lt;/span&gt;) &lt;span style=&#34;color:#66d9ef&#34;&gt;continue&lt;/span&gt;;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      &#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;计算距离&lt;/span&gt;;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;更新结果集&lt;/span&gt;;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;加入候选队列&lt;/span&gt;;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// 3.3 提前终止检查&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;候选集中最近距离&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;结果集中最远距离&lt;/span&gt;) {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      &lt;span style=&#34;color:#66d9ef&#34;&gt;break&lt;/span&gt;;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  }&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#75715e&#34;&gt;// 4. 返回结果&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;最近的&lt;/span&gt;k个节点;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</description>
    </item>
    <item>
      <title>IVFFlat索引在Bustub中的实现</title>
      <link>//localhost:1313/posts/zh/vectordb/ivfflat%E7%B4%A2%E5%BC%95%E5%9C%A8bustub%E4%B8%AD%E7%9A%84%E5%AE%9E%E7%8E%B0/</link>
      <pubDate>Sat, 30 Nov 2024 19:42:02 +0800</pubDate>
      <guid>//localhost:1313/posts/zh/vectordb/ivfflat%E7%B4%A2%E5%BC%95%E5%9C%A8bustub%E4%B8%AD%E7%9A%84%E5%AE%9E%E7%8E%B0/</guid>
      <description>&lt;h3 id=&#34;ivfflat索引&#34;&gt;IVFFlat索引&lt;/h3&gt;&#xA;&lt;p&gt;IVF（Inverted File Index，倒排文件索引）是一种常用于向量搜索（ANN, Approximate Nearest Neighbor）的索引结构，主要用于高维数据检索，比如图像、文本、音频等向量数据的相似性搜索。&lt;/p&gt;&#xA;&lt;p&gt;本文主要介绍IVFFlat索引在Bustub中的实现，主要从以下三个方面来回答：&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;IVFFlat索引的概述&lt;/li&gt;&#xA;&lt;li&gt;IVFFlat索引在向量数据库中的应用&lt;/li&gt;&#xA;&lt;li&gt;IVFFlat索引在Bustub中的实现&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h2 id=&#34;ivfflat索引的概述&#34;&gt;IVFFlat索引的概述&lt;/h2&gt;&#xA;&lt;p&gt;IVF 通过聚类将向量划分到不同的“桶”（centroids, 聚类中心），查询时只在最相关的桶中搜索，从而减少计算量。&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;strong&gt;训练阶段&lt;/strong&gt;：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;使用 &lt;strong&gt;K-means&lt;/strong&gt; 聚类将所有数据点分成 ( K ) 个簇（每个簇有一个中心）。&lt;/li&gt;&#xA;&lt;li&gt;每个向量根据与哪个中心最近，归属于该中心对应的桶。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;strong&gt;索引构建&lt;/strong&gt;：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;记录每个桶中的向量 ID 及其原始向量。&lt;/li&gt;&#xA;&lt;li&gt;形成一个 &lt;strong&gt;倒排表&lt;/strong&gt;，即每个簇对应多个向量。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;strong&gt;查询阶段&lt;/strong&gt;：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;先找到查询向量最接近的 ( N ) 个簇中心（通常 ( N \ll K )）。&lt;/li&gt;&#xA;&lt;li&gt;只在这些簇对应的桶内进行精确搜索，而不是全量搜索。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;hr&gt;&#xA;&lt;h3 id=&#34;示例&#34;&gt;&lt;strong&gt;示例&lt;/strong&gt;&lt;/h3&gt;&#xA;&lt;p&gt;假设有 100 万个 128 维向量：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;用 K-means 训练出 &lt;strong&gt;1000 个簇中心&lt;/strong&gt;（K=1000）。&lt;/li&gt;&#xA;&lt;li&gt;每个向量归类到最近的簇，存入倒排表。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;当查询时：&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;计算查询向量与 1000 个簇中心的距离，找到最近的 10 个簇。&lt;/li&gt;&#xA;&lt;li&gt;只在这 10 个簇对应的桶里搜索最近邻，而不是在全部 100 万个向量中搜索。&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;这样，计算量大大减少，提高了搜索速度。&lt;/p&gt;&#xA;&lt;hr&gt;&#xA;&lt;h3 id=&#34;ivf-的优点&#34;&gt;&lt;strong&gt;IVF 的优点&lt;/strong&gt;&lt;/h3&gt;&#xA;&lt;p&gt;✅ &lt;strong&gt;高效查询&lt;/strong&gt;：比暴力搜索（Brute-force）快很多，适用于大规模数据。&lt;br&gt;&#xA;✅ &lt;strong&gt;可扩展&lt;/strong&gt;：K 值可调，适应不同数据规模。&lt;br&gt;&#xA;✅ &lt;strong&gt;支持 ANN（近似最近邻搜索）&lt;/strong&gt;：可以搭配其他方法（如 PQ, HNSW）进一步加速。&lt;/p&gt;</description>
    </item>
    <item>
      <title>匹配向量索引</title>
      <link>//localhost:1313/posts/zh/vectordb/%E5%8C%B9%E9%85%8D%E5%90%91%E9%87%8F%E7%B4%A2%E5%BC%95/</link>
      <pubDate>Sun, 10 Nov 2024 19:42:02 +0800</pubDate>
      <guid>//localhost:1313/posts/zh/vectordb/%E5%8C%B9%E9%85%8D%E5%90%91%E9%87%8F%E7%B4%A2%E5%BC%95/</guid>
      <description>&lt;h1 id=&#34;匹配向量索引任务介绍概述&#34;&gt;匹配向量索引任务介绍概述&lt;/h1&gt;&#xA;&lt;p&gt;这个任务的目标是根据查询中的条件，判断是否可以将查询转换为向量索引扫描，并在可能的情况下使用该索引。通过这种方式，你可以显著提高向量最近邻查询的效率，避免全表扫描。&lt;/p&gt;&#xA;&lt;p&gt;具体来说，你需要实现一个优化规则，该规则能够识别出需要执行&lt;strong&gt;向量索引扫描&lt;/strong&gt;的SQL查询，并将这些查询转换成使用向量索引的执行计划。任务的关键部分是优化器（optimizer），你需要根据查询的结构和给定的索引类型选择合适的索引进行查询优化。&lt;/p&gt;&#xA;&lt;h3 id=&#34;任务步骤&#34;&gt;任务步骤：&lt;/h3&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;strong&gt;识别查询&lt;/strong&gt;：首先，优化器需要识别SQL查询中是否有需要使用向量索引的部分。查询通常会包含计算向量距离（如&lt;code&gt;&amp;lt;-&amp;gt;&lt;/code&gt;）的条件，这时候就可能需要使用索引扫描来替代全表扫描。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;strong&gt;转换为向量索引扫描&lt;/strong&gt;：当确认查询能使用向量索引时，优化器需要将查询计划转换为&lt;strong&gt;向量索引扫描&lt;/strong&gt;。这个过程包括：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;查找查询中的&lt;strong&gt;向量列&lt;/strong&gt;，通常是表中的第一个向量列。&lt;/li&gt;&#xA;&lt;li&gt;选择一个可用的索引（如HNSW或IVFFlat）来优化查询。&lt;/li&gt;&#xA;&lt;li&gt;将查询转换为一个新的查询计划节点，替代传统的全表扫描和排序操作。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;strong&gt;支持的查询类型&lt;/strong&gt;：你需要处理不同形式的查询，特别是带有&lt;code&gt;ORDER BY&lt;/code&gt;和&lt;code&gt;LIMIT&lt;/code&gt;子句的查询。例如，查询可能包含按向量距离排序并限制返回结果数量的操作，这些查询应转换为使用向量索引扫描。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;strong&gt;索引选择策略&lt;/strong&gt;：在优化器中，你需要实现一个策略来选择合适的索引。可以选择以下几种策略：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;strong&gt;空值&lt;/strong&gt;（默认）：选择第一个可用的向量索引。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;HNSW&lt;/strong&gt;：只匹配HNSW索引。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;IVFFlat&lt;/strong&gt;：只匹配IVFFlat索引。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;无索引&lt;/strong&gt;：不使用任何索引，进行精确的最近邻搜索。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h3 id=&#34;处理的三种情况&#34;&gt;处理的三种情况&lt;/h3&gt;&#xA;&lt;p&gt;优化器需要处理以下三种常见的查询结构，并根据情况选择使用向量索引扫描：&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;strong&gt;情况1：TopN直接跟随SeqScan&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-text&#34; data-lang=&#34;text&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;TopN { n=2, order_bys=[(&amp;#34;Default&amp;#34;, &amp;#34;l2_dist([1.000000,1.000000,1.000000], #0.0)&amp;#34;)]}&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  SeqScan { table=t1 }&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这种情况下，查询直接使用了&lt;code&gt;TopN&lt;/code&gt;（即返回前&lt;code&gt;k&lt;/code&gt;个结果），并且顺序扫描表。此时可以直接将&lt;code&gt;SeqScan&lt;/code&gt;替换为向量索引扫描。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;strong&gt;情况2：TopN跟随Projection&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-text&#34; data-lang=&#34;text&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;TopN { n=2, order_bys=[(&amp;#34;Default&amp;#34;, &amp;#34;l2_dist([1.000000,1.000000,1.000000], #0.0)&amp;#34;)]}&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  Projection { exprs=[&amp;#34;#0.0&amp;#34;, &amp;#34;l2_dist([1.000000,1.000000,1.000000], #0.0)&amp;#34;] }&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    SeqScan { table=t1 }&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;在这种情况下，&lt;code&gt;TopN&lt;/code&gt;操作之后有一个&lt;code&gt;Projection&lt;/code&gt;操作，需要对结果进行投影。优化器仍然可以将&lt;code&gt;SeqScan&lt;/code&gt;替换为向量索引扫描，并在索引扫描后加上投影操作，以保持查询语义。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;strong&gt;情况3：TopN跟随Projection并且列顺序变换&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-text&#34; data-lang=&#34;text&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;TopN { n=2, order_bys=[(&amp;#34;Default&amp;#34;, &amp;#34;l2_dist([1.000000,1.000000,1.000000], #0.1)&amp;#34;)]}&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  Projection { exprs=[&amp;#34;#0.1&amp;#34;, &amp;#34;#0.0&amp;#34;] }&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    SeqScan { table=t1 }&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这种情况与情况2类似，但投影中列的顺序发生了变化，优化器需要正确地识别出列的映射，并在向量索引扫描后执行相应的投影。&lt;/p&gt;</description>
    </item>
    <item>
      <title>Pika-Acl无权限BUG</title>
      <link>//localhost:1313/posts/zh/pika/pika-acl%E6%97%A0%E6%9D%83%E9%99%90bug/</link>
      <pubDate>Sun, 20 Oct 2024 19:42:02 +0800</pubDate>
      <guid>//localhost:1313/posts/zh/pika/pika-acl%E6%97%A0%E6%9D%83%E9%99%90bug/</guid>
      <description>&lt;h1 id=&#34;pika-acl问题分析与解决方案&#34;&gt;Pika ACL问题分析与解决方案&lt;/h1&gt;&#xA;&lt;h2 id=&#34;配置详情&#34;&gt;配置详情&lt;/h2&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-ini&#34; data-lang=&#34;ini&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;requirepass: 123&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# Password for replication verify, used for authentication when a slave&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# connects to a master to request replication.&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# [NOTICE] The value of this parameter must match the &amp;#34;requirepass&amp;#34; setting on the master.&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;masterauth:&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# The [password of user], which is empty by default.&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# [NOTICE] If this user password is the same as admin password (including both being empty),&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# the value of this parameter will be ignored and all users are considered as administrators,&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# in this scenario, users are not subject to the restrictions imposed by the userblacklist.&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# PS: &amp;#34;admin password&amp;#34; refers to value of the parameter above: requirepass.&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# userpass:&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# The blacklist of commands for users that logged in by userpass,&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# the commands that added to this list will not be available for users except for administrator.&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# [Advice] It&amp;#39;s recommended to add high-risk commands to this list.&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# [Format] Commands should be separated by &amp;#34;,&amp;#34;. For example: FLUSHALL, SHUTDOWN, KEYS, CONFIG&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# By default, this list is empty.&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;userblacklist: FLUSHALL, flushdb&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;hr&gt;&#xA;&lt;h2 id=&#34;issue-描述&#34;&gt;Issue 描述&lt;/h2&gt;&#xA;&lt;h3 id=&#34;配置情况&#34;&gt;配置情况：&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;code&gt;requirepass: xxx&lt;/code&gt;（管理员密码）&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;userpass:&lt;/code&gt;（未设置）&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;userblacklist: FLUSHALL&lt;/code&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;&lt;strong&gt;问题&lt;/strong&gt;：&lt;/p&gt;</description>
    </item>
    <item>
      <title>阿里云天池云oceanbase对obcdc输出信息重新打标</title>
      <link>//localhost:1313/posts/zh/opensource/%E9%98%BF%E9%87%8C%E4%BA%91%E5%A4%A9%E6%B1%A0%E4%BA%91oceanbase%E5%AF%B9obcdc%E8%BE%93%E5%87%BA%E4%BF%A1%E6%81%AF%E9%87%8D%E6%96%B0%E6%89%93%E6%A0%87/</link>
      <pubDate>Tue, 20 Aug 2024 19:42:02 +0800</pubDate>
      <guid>//localhost:1313/posts/zh/opensource/%E9%98%BF%E9%87%8C%E4%BA%91%E5%A4%A9%E6%B1%A0%E4%BA%91oceanbase%E5%AF%B9obcdc%E8%BE%93%E5%87%BA%E4%BF%A1%E6%81%AF%E9%87%8D%E6%96%B0%E6%89%93%E6%A0%87/</guid>
      <description>&lt;h1 id=&#34;1-项目概述&#34;&gt;1. 项目概述&lt;/h1&gt;&#xA;&lt;h2 id=&#34;11-项目背景&#34;&gt;1.1 项目背景&lt;/h2&gt;&#xA;&lt;p&gt;OceanBase 是自研的企业级原生分布式数据库，支持“数据零丢失”标准，兼容 Oracle/MySQL，提供无缝水平扩展，首创“三地五中心”城市级故障自动无损容灾新标准，刷新 TPC-C 标准测试，单集群规模超过 1500 节点，具有云原生、强一致性、高度兼容 Oracle/MySQL 等特性。采用高压缩引擎和多租户架构，显著降低存储和运维成本。支持实时交易和分析，确保数据一致性，同时具备完备的安全性，经过多年金融核心场景验证，自主研发保障代码可控和高可靠性。&lt;/p&gt;&#xA;&lt;h2 id=&#34;12-目前现状&#34;&gt;1.2 目前现状&lt;/h2&gt;&#xA;&lt;p&gt;oblogminer 在处理 obcdc 输出的结果时，对于无法判断的列值，通常会使用标记 &lt;code&gt;/* POTENTIALLY INACCURATE */&lt;/code&gt; 来表示这些列值可能不准确。&lt;/p&gt;&#xA;&lt;h2 id=&#34;13-预期目标&#34;&gt;1.3 预期目标&lt;/h2&gt;&#xA;&lt;p&gt;使 oblogminer 能够在 obcdc 4.3.1 版本及之后的版本中，正确识别列值的可信性，并根据 obcdc 的标记输出可信的列值，无需标记为 &lt;code&gt;/* POTENTIALLY INACCURATE */&lt;/code&gt;。&lt;/p&gt;&#xA;&lt;p&gt;对于判断列值是否可信的场景：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;code&gt;oblogmsg&lt;/code&gt; 库中 &lt;code&gt;ValueOrigin.h&lt;/code&gt; 中的 &lt;code&gt;enum&lt;/code&gt; 类型 &lt;code&gt;VALUE_ORIGIN&lt;/code&gt; 代表了列值来源。&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;VALUE_ORIGIN::REDO&lt;/code&gt; 代表列值来源于日志，说明该列为可信的。&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;VALUE_ORIGIN::PADDING&lt;/code&gt; 代表列值来源于 OBCDC 自己生成的，不代表真实列值。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;14-参考信息&#34;&gt;1.4 参考信息&lt;/h2&gt;&#xA;&lt;p&gt;在 &lt;code&gt;delete&lt;/code&gt; 操作后，CDC 拿到的数据中，BLOB 类型的列值被设置为 &lt;code&gt;NULL&lt;/code&gt;，而 TEXT 类型的列值则保留了原始数据。这导致从节点复制失败。CDC 应该能够处理 BLOB 列的正确值，而不是将其设为 &lt;code&gt;NULL&lt;/code&gt;。&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;复现步骤：&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;创建表 &lt;code&gt;t_blob_text&lt;/code&gt;，包含一个 &lt;code&gt;BLOB&lt;/code&gt; 列和一个 &lt;code&gt;TEXT&lt;/code&gt; 列。&lt;/li&gt;&#xA;&lt;li&gt;插入一行数据，其中 &lt;code&gt;BLOB&lt;/code&gt; 列包含 16383 个“😂”字符，&lt;code&gt;TEXT&lt;/code&gt; 列包含 300 个“犇”字。&lt;/li&gt;&#xA;&lt;li&gt;执行 &lt;code&gt;delete&lt;/code&gt; 操作删除表中的所有数据。&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;&lt;strong&gt;期望行为：&lt;/strong&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>腾讯犀牛鸟开源-加权轮询算法</title>
      <link>//localhost:1313/posts/zh/opensource/%E8%85%BE%E8%AE%AF%E7%8A%80%E7%89%9B%E9%B8%9F%E5%BC%80%E6%BA%90%E5%8A%A0%E6%9D%83%E8%BD%AE%E8%AF%A2%E7%AE%97%E6%B3%95/</link>
      <pubDate>Sat, 20 Jul 2024 19:42:02 +0800</pubDate>
      <guid>//localhost:1313/posts/zh/opensource/%E8%85%BE%E8%AE%AF%E7%8A%80%E7%89%9B%E9%B8%9F%E5%BC%80%E6%BA%90%E5%8A%A0%E6%9D%83%E8%BD%AE%E8%AF%A2%E7%AE%97%E6%B3%95/</guid>
      <description>&lt;h1 id=&#34;平滑加权轮询负载均衡插件&#34;&gt;平滑加权轮询负载均衡插件&lt;/h1&gt;&#xA;&lt;h2 id=&#34;一概述&#34;&gt;一、概述&lt;/h2&gt;&#xA;&lt;p&gt;为了避免传统加权轮询中可能出现的负载不均衡，采用平滑加权轮询（Smooth Weighted Round-Robin，简称 SWRR）。它通常用于将请求分配到一组服务器中，以达到更均衡的负载分配。在传统的加权轮询（Weighted Round-Robin）基础上，通过平滑处理来避免负载分配的不均匀性。&lt;/p&gt;&#xA;&lt;h2 id=&#34;二具体实现&#34;&gt;二、具体实现&lt;/h2&gt;&#xA;&lt;p&gt;平滑加权轮询算法的目标是减少传统加权轮询算法中的不均衡现象，尤其是在请求到达不均匀或服务器负载变化的情况下。该算法通过以下方式来平滑负载分配：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;strong&gt;加权池&lt;/strong&gt;：服务器的权重决定了它们在加权池中的出现频率。平滑加权轮询算法会在轮询过程中根据权重动态调整每台服务器的“虚拟”权重，使得负载分配更均匀。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;平滑处理&lt;/strong&gt;：算法会计算每台服务器的负载和权重，并在每次分配请求时，基于服务器的负载情况调整请求的分配。这种方式确保了高负载的服务器不会被过度分配请求，从而避免了负载过度集中。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;动态调整&lt;/strong&gt;：当服务器的负载发生变化时，算法会动态调整权重值，以确保负载在服务器之间的分配更加合理。例如，如果某台服务器变得很繁忙，它的权重值可能会被降低，从而减少它接收请求的频率。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;示例&#34;&gt;示例&lt;/h3&gt;&#xA;&lt;p&gt;假设有三个节点 A、B、C，它们的权重分别为 5、1、1。初始时，各节点的当前权重为 0。&lt;/p&gt;&#xA;&lt;h4 id=&#34;第一次请求&#34;&gt;第一次请求：&lt;/h4&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;A：0 + 5 = 5&#xA;B：0 + 1 = 1&#xA;C：0 + 1 = 1&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;选择 A，因为 A 的当前权重最高。然后 A 的当前权重变为 &lt;code&gt;5 - (5 + 1 + 1) = -2&lt;/code&gt;。&lt;/p&gt;&#xA;&lt;h4 id=&#34;第二次请求&#34;&gt;第二次请求：&lt;/h4&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;A：-2 + 5 = 3&#xA;B：1 + 1 = 2&#xA;C：1 + 1 = 2&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;选择 A，因为 A 的当前权重仍然最高。然后 A 的当前权重变为 &lt;code&gt;3 - (5 + 1 + 1) = -4&lt;/code&gt;。&lt;/p&gt;</description>
    </item>
    <item>
      <title>基于Simhash实现PSM概率性匹配系统</title>
      <link>//localhost:1313/posts/zh/opensource/%E5%9F%BA%E4%BA%8Esimhash%E5%AE%9E%E7%8E%B0psm%E6%A6%82%E7%8E%87%E6%80%A7%E5%8C%B9%E9%85%8D%E7%B3%BB%E7%BB%9F/</link>
      <pubDate>Thu, 20 Jun 2024 19:42:02 +0800</pubDate>
      <guid>//localhost:1313/posts/zh/opensource/%E5%9F%BA%E4%BA%8Esimhash%E5%AE%9E%E7%8E%B0psm%E6%A6%82%E7%8E%87%E6%80%A7%E5%8C%B9%E9%85%8D%E7%B3%BB%E7%BB%9F/</guid>
      <description>&lt;p&gt;&lt;strong&gt;基于Simhash实现PSM概率性匹配系统&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;p&gt;PSM系统，即概率性&lt;strong&gt;Simhash匹配系统&lt;/strong&gt;（Probabilistic Simhash Matching System），是一种用于高效检测近似重复图像或文档的算法系统。它利用&lt;strong&gt;Simhash技术&lt;/strong&gt;，通过概率性匹配方法来快速识别和定位相似度较高的对象。&#xA;&lt;img src=&#34;./images/1280X1280.PNG&#34; alt=&#34;simhash&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;Simhash和汉明距离&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;p&gt;Simhash由Moses Charikar开发，并在他的论文“Similarity Estimation Techniques from Rounding Algorithms”中描述。Simhash的主要目的是将相似的项目哈希到相似的哈希值。相似性可以通过哈希值之间的位汉明距离来判断。&lt;/p&gt;&#xA;&lt;p&gt;以下是将一个n维实数向量映射到一个f位Simhash的算法。&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;算法1：计算实数向量的Simhash&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;输入：&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;p&gt;v[1..n]：输入实数向量&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;输出：&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;p&gt;s：f位Simhash&lt;/p&gt;&#xA;&lt;p&gt;初始化一个实数向量t[1..f]为0&lt;/p&gt;&#xA;&lt;p&gt;生成n个f位随机整数r[1..n]&lt;/p&gt;&#xA;&lt;p&gt;对于i从1到n，执行以下步骤：&lt;/p&gt;&#xA;&lt;p&gt;对于j从1到f，执行以下步骤：&lt;/p&gt;&#xA;&lt;p&gt;如果r[i]的第j位是1，则t[j] ← t[j] + v[i]&lt;/p&gt;&#xA;&lt;p&gt;否则，t[j] ← t[j] − v[i]&lt;/p&gt;&#xA;&lt;p&gt;对于i从1到f，执行以下步骤：&lt;/p&gt;&#xA;&lt;p&gt;如果t[i] ≥ 0，则将s的第i位设为1&lt;/p&gt;&#xA;&lt;p&gt;否则，将s的第i位设为0&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;近似重复检测&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;p&gt;一般来说，如果两个Simhash的汉明距离不超过h（h是一个经验阈值），我们可以认为它们是近似重复的。要在一个包含m个Simhash的数据库中找到一个Simhash的所有近似重复，最简单的方法是进行一次完整的线性扫描，这需要计算m次汉明距离。&lt;/p&gt;&#xA;&lt;p&gt;随着m的增长，完整线性扫描的时间成本将变得不可接受。事实上，大多数汉明距离计算是没有必要的，因为对于每个查询的Simhash，只有少数近似重复可以找到。已经提出了几种解决方案来减少比较的时间，例如Manku等人（2007年）。&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;位翻转组合&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;p&gt;我们考虑Sood和Luguinov提出的一种新方法，即概率性Simhash匹配（PSM）系统，该系统在不需要维护数据的多个副本以进行近似重复搜索的情况下，仍然保持了良好的召回率。对于给定的查询指纹，我们基于找到近似重复匹配的概率探索不同的现有指纹，并限制我们的尝试次数以实现良好的查询速度。&lt;/p&gt;&#xA;&lt;p&gt;首先，我们可以对Si69521mhash数据库进行排序并建立一个索引。为了更好地理解这里的“索引”，假设所有的Simhash都是f位整数并按列表排序，我们根据每个Simhash的前p位将它们分成子列表，然后所有子列表中第一个元素的位置组成一个索引。例如，索引的第32767个元素表示Simhash列表中前p位等于0x7fff的最小元素的位置。由于汉明距离阈值h通常是2或3，我们可以轻松构建位翻转组合，这意味着查询Simhash的所有可能的前16位的近似重复。对于h=3和p=16的索引，我们需要扫描所有65536（2^16）个子列表进行完整线性扫描，但仅需要扫描C(p,0) + C(p,1) + C(p,2) + C(p,3) = 697个子列表，受益于位翻转组合。&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;计算Simhash&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;Simhash 原理概述&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;p&gt;Simhash 的基本思想是通过特征向量的加权累加生成一个低维哈希值，进而用于判断相似性。对于文本来说，特征可以是单词或词组，对于实数向量来说，特征就是向量的每一个分量。&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;将实数向量映射到 Simhash 的过程&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;p&gt;对于文本，我们通常将每个单词哈希为一个固定长度的位串，并根据单词的权重对这些位串进行加权累加。而对于实数向量，我们可以使用类似的过程，将每个向量分量视为一个特征，进行加权累加。具体步骤如下：&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;输入：&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;p&gt;v[1..n]v[1..n]v[1..n]：输入的实数向量&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;输出：&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;p&gt;sss：f 位 Simhash&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;步骤：&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;初始化向量&lt;/strong&gt;：&lt;/p&gt;&#xA;&lt;p&gt;初始化一个长度为 f 的实数向量 t[1..f]t[1..f]t[1..f]，所有值设为 0。&lt;/p&gt;</description>
    </item>
    <item>
      <title>关于我</title>
      <link>//localhost:1313/about/</link>
      <pubDate>Thu, 21 Mar 2024 00:00:00 +0000</pubDate>
      <guid>//localhost:1313/about/</guid>
      <description>&lt;h1 id=&#34;-你好我是-刘恒胜&#34;&gt;👋 你好，我是 刘恒胜&lt;/h1&gt;&#xA;&lt;p&gt;来自西安财经大学 信息工程学院 网络工程专业&lt;/p&gt;&#xA;&lt;h2 id=&#34;-工作经历&#34;&gt;💼 工作经历&lt;/h2&gt;&#xA;&lt;h3 id=&#34;奇虎360北京总部&#34;&gt;奇虎360(北京总部)&lt;/h3&gt;&#xA;&lt;p&gt;&lt;em&gt;Pika是一个高性能、高容量、多租户的KV存储系统，支持数据持久化，完全兼容Redis协议，已在GitHub上获得超过5.9k stars。&lt;/em&gt;&lt;/p&gt;&#xA;&lt;h4 id=&#34;pika-主从一致性开发&#34;&gt;Pika 主从一致性开发：&lt;/h4&gt;&#xA;&lt;p&gt;&lt;em&gt;pika主从复制采用异步追赶复制，在遇到主节点故障后，重新选主后的主节点可能不具备完整的数据，故在对数据完整性要求高的场景，需要采用强一致性协议，在和团队成员讨论后，由我独立负责PacificA协议进行一致性开发。&lt;/em&gt;&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;strong&gt;PacificA 主从数据一致性流程&lt;/strong&gt; :重新设计主从数据交互的全链路处理流程，包含进行主从元数据同步MetaSync，确保主从一致性标记、数据完整性检查TrySync、进行全量或增量同步、从作为Candidate、追加完整的准备列表、BinlogSync通过日志和心跳包确保数据复制四个核心阶段。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;strong&gt;采用逻辑复制方式&lt;/strong&gt;:主节点负责日志追加并确保提交点前移，从节点按照提交点进行数据写入，保证主从一致性。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;strong&gt;分布式日志存储系统开发&lt;/strong&gt;:先将数据写入日志，再更新内存数据结构，并定期创建检查点防止日志无限增长。创建检查点后进行日志截断，减少存储压力。在系统崩溃时，可利用日志回放机制恢复数据，保证高可用性。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;strong&gt;故障恢复与状态协调&lt;/strong&gt;:重新选举新的主节点时，将所有副本的 preparedID 对齐新主节点的preparedID。新主节点提交所有已准备的日志，使 preparedID 和 committedID 一致，保证日志完整性。写请求流程：先写 binlog，等待所有从节点追加日志后，再执行数据库写入，确保数据不会丢失或回滚失败。超时则记录异常退出，保障系统在恢复后仍具备数据一致性和高可用性，确保在 n-1 节点故障时仍具备容错能力。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h4 id=&#34;pika-operator开发&#34;&gt;Pika-Operator开发&lt;/h4&gt;&#xA;&lt;p&gt;&lt;em&gt;Pika-Operator主要采用kubeblocks进行开发，提供了去中心化，模块化架构，并具有两种集群模式，集群部署，动态扩缩容。&lt;/em&gt;&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;strong&gt;主从集群优化与升级&lt;/strong&gt;:基于最新的Operator升级K8s集群，添加 Role 模块并优化 Pika 主从流程，解决部分 Pod 失效问题。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;备份与恢复组件&lt;/strong&gt;:学习Pika的Bgsave流程，完成BackupPolicy，并结合CSI配置并连接S3，实现了自动备份与恢复。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h4 id=&#34;解决dba线上遇到的bug&#34;&gt;解决DBA线上遇到的BUG：&lt;/h4&gt;&#xA;&lt;p&gt;解决了ACl中普通用户无权限问题，开发pika-export版本管理，协助解决快慢命令时间统计问题。&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;个人总结&lt;/strong&gt;: 我深入研究了系统源码，对pika多线程模型，主从架构了清晰的认识，深入学习了Kubernetes，docker及Operator相关知识，研读并总结了微软的PacificA论文，并与团队成员积极讨论。&lt;/p&gt;&#xA;&lt;h2 id=&#34;-开源贡献&#34;&gt;🌟 开源贡献&lt;/h2&gt;&#xA;&lt;h3 id=&#34;腾讯犀牛鸟计划---负载均衡插件开发&#34;&gt;腾讯犀牛鸟计划 - 负载均衡插件开发&lt;/h3&gt;&#xA;&lt;p&gt;&lt;em&gt;issue描述：实现IP直连负载均衡插件 - 加权轮询算法，通过分配权重，将请求分配到不同服务器上，尽可能提高集群的处理请求量&lt;/em&gt;&lt;/p&gt;&#xA;&lt;p&gt;SWRR 通过在每轮分配时调整服务器权重，避免短时间内的负载集中，使得服务器的请求数量与其权重成比例。编写单元测试，通过了异步选择、以及动态端点的处理等场景.&lt;/p&gt;&#xA;&lt;h3 id=&#34;阿里天池云原生挑战赛---oceanbase&#34;&gt;阿里天池云原生挑战赛 - OceanBase&lt;/h3&gt;&#xA;&lt;p&gt;&lt;em&gt;issue描述：oblogminer 在处理 obcdc 输出的结果时，对于无法判断的列值，通常会使用标记来表示这些列值可能不准确&lt;/em&gt;&lt;/p&gt;&#xA;&lt;p&gt;修复了源于日志LOB类型为NULL标记不准确，修复了MINIMAL模式下，其他列类型也可能产生不可靠的结果，代码现在检查每个列值的来源&lt;/p&gt;&#xA;&lt;h2 id=&#34;-项目经历&#34;&gt;🚀 项目经历&lt;/h2&gt;&#xA;&lt;h3 id=&#34;bustub-vectordb-向量数据库开发&#34;&gt;Bustub Vectordb 向量数据库开发&lt;/h3&gt;&#xA;&lt;p&gt;&lt;strong&gt;2024.10 - 2024.11&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;p&gt;&lt;em&gt;Bustub_Vectordb一个基于 CMU-DB 的 BusTub 系统，支持向量存储、相似检索的关系型数据库&lt;/em&gt;&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
